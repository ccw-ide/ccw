#Thu Nov 24 13:53:39 CET 2011
cmdhistory=["(def e1 [{\:a 1 \:b \\"b\\" \:c 300 }{\:a 2 \:b \\"a\\" \:c 500 }])\\r\\n(def e2 [{\:a 1 \:d \\"blah\\"}{\:a 2 \:d \\"blah2\\"}])" "(map merge e1 e2)" "(def toto.titi \\"salut\\")" "toto.titi" "user/toto.titi" "toto.titi" "\#'toto.titi" "@\#'toto.titi" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\EditorSupport.clj" "(doc delay)" "(doc add-watch)" "(def d (delay nil))" "(add-watch d \:toto identity)" "(def f (future \\"foo\\"))" "(add-watch f \:future identity)" "(macroexpand '(let [toto] titi))" "(macroexpand '(let [toto tutu] titi))" "(macroexpand '\#(let [toto tutu] titi))" "(doc delay)" "(true? true)" "(true? \\"\\")" "(doc future)" "(compile 'ccw.editors.antlrbased.PareditAutoEditStrategy)" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\EditorSupport.clj" "(binding [*compile-path* \\"C\:\\\\Users\\\\Laurent\\\\var\\\\projects\\\\ccw\\\\ccw.core\\\\classes\\", *compile-files* true] (compile 'ccw.editors.antlrbased.EditorSupport))" "(binding [*compile-path* \\"C\:/Users/Laurent/var/projects/ccw/ccw.core/classes\\", *compile-files* true] (compile 'ccw.editors.antlrbased.EditorSupport))" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\EditorSupport.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\PareditAutoEditStrategy.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\EditorSupport.clj" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\lrplus.clj" ";; Loading file src\\\\net\\\\cgrand\\\\parsley.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\ClojureFormat.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\ClojureHyperlink.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\ClojureHyperlinkDetector.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\ClojureHyperlink.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\ClojureHyperlinkDetector.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\EditorSupport.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\handlers.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\StacktraceHyperlink.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\ClojureHyperlink.clj" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(def d [\\"(salut\\" \\" les c\\" \\"opa\\" \\"ins)\\"])" ";; Switching to paredit.parser namespace" "(dser-ser-inc d)" "(def d (var-get \#'user/d))" "d" "(def d (var-get \#'user/d))" "(dser-ser-inc d)" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(dser-ser-inc d)" ";; Loading file test\\\\paredit\\\\tests.clj" ";; Switching to paredit.tests namespace" "(pts)" "(sexp \\"toto\\")" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(sexp \\"toto\\")" "(sexp \\"()\\")" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\lrplus.clj" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\fold.clj" "(sexp \\"\\")" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\EditorSupport.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\PareditAutoEditStrategy.clj" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\ClojureFormat.clj" "(doc assert)" "*assert*" ";; Loading file src\\\\ccw\\\\editors\\\\antlrbased\\\\EditorSupport.clj" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(edit-buffer nil 0 0 \\"coucou\\")" "(edit-buffer *1 0 0 \\"coucou\\")" "(-> sexp p/incremental-buffer (p/edit 0 0 \\"123\\"))" "(-> sexp p/incremental-buffer (p/edit 0 0 \\"123\\") (p/edit 0 3 \\"\\"))" "(-> sexp p/incremental-buffer (p/edit 0 0 \\"123\\") (p/edit 0 3 nil))" "(-> sexp p/incremental-buffer (p/edit 0 0 \\"123\\") p/parse-tree)" "(-> sexp p/incremental-buffer (p/edit 0 0 \\"yo man\\") p/parse-tree)" "(-> sexp p/incremental-buffer (p/edit 0 0 \\"yo() man\\") p/parse-tree)" "(-> sexp p/incremental-buffer (p/edit 0 0 \\"yo() man\\") (p/edit 0 0 \\"c\\") p/parse-tree)" ";; Loading file src\\\\net\\\\cgrand\\\\parsley\\\\fold.clj" ";; Loading file src\\\\paredit\\\\parser.clj" ";; Switching to paredit.parser namespace" "(sexp \\"salut\\")" ";; Switching to paredit.parser namespace" "(sexp \\"salut\\")" "(sexp \\"salut)\\")" "(sexp \\"(salut||)|\\")" "(sexp \\"(salut||)|]]]]]\\")" ";; Loading file test\\\\paredit\\\\tests.clj" ";; Switching to paredit.tests namespace" "(pts)" ";; Loading file test\\\\paredit\\\\tests.clj" ";; Switching to paredit.tests namespace" "(pts)" "(pprint (sexp \\"foo3 bar baz\\"))" "(defprotocol Addable\\r\\n (add-fields [this]))" "(defrecord MyRecord [a b])" "(doc extend-type)" "(extend-type MyRecord\\r\\n Addable\\r\\n (add-fields [this] (+ a b)))" "(extend-type MyRecord\\r\\n Addable\\r\\n (add-fields [this] (+ (this a) (this b))))" "(extend-type MyRecord\\r\\n Addable\\r\\n (add-fields [this] (+ (this \:a) (this \:b))))" "(defn indirect-adder [a b]\\r\\n (add-fields (MyRecord. a b)))" "(indirec-adder 1 2)" "(indirect-adder 1 2)" "(extend-type MyRecord\\r\\n Addable\\r\\n (add-fields [this] (+ (\:a this) (\:b this))))" "(indirect-adder 1 2)" "(binding [add-fields (fn [_] \\"hello\!\\")] (indirect-adder 1 2))" ";; Switching to paredit.parser namespace" "(sexp \\"]\\")" "(def a (ref {\:document nil}))" "a" "@a" "(dosync (alter a assoc \:document \:d))" "a" "@a" ";; Loading file src\\\\paredit\\\\parser.clj" "(require 'ccw.ClojureProjectNatureImpl)" ";; Loading file src\\\\ccw\\\\ClojureProjectNatureImpl.clj" "ccw.editors.clojure.ClojureHyperlink." "ccw.editors.clojure.ClojureHyperlink\\n" "(if-let [[x & xs] \#{}] true false)" "(defn pivot-idx [l get count] (get l (/ 2 (count l))))" "(pivot-idx [1 2 3] get count)" "(defn pivot-idx [l get count] (get l (/ 2 (dec (count l)))))" "(pivot-idx [1 2 3] get count)\\n" "(pivot-idx [1 2] get count)\\n" "(get [1 2] 0)" "(pivot-idx [1 2] get count)\\n" "(defn pivot-idx [l get count] (get l (let [i (/ 2 (dec (count l)))] (print i) i)))" "(pivot-idx [1 2] get count)\\n" "(dec 2)" "(defn pivot-idx [l get count] (get l (let [i (/ (dec (count l)) 2)] (print i) i)))" "(pivot-idx [1 2] get count)\\n" "(rem 1/2)" "(rem 2 2)" "(rem 4 2)" "(quot 4 2)" "(quote 5 2)" "(quot 5 2)" "(quot 6 2)" "(quot 1 2)" "(quot 2 2)" "(defn pivot-idx [l get count] (get l (let [i (quot (count l))] (print i) i)))" "(quot 2 2)" "(pivot-idx [1 2] get count)\\n" "(defn pivot-idx [l get count] (get l (let [i (quot (count l) 2)] (print i) i)))" "(pivot-idx [1 2] get count)\\n" "(defn pivot-idx [l get count] (get l (let [i (quot (count l) 2)] i)))" "(pivot-idx [1 2])" "(pivot-idx [1 2] get count)" "(pivot-idx [\:a \:b] get count)" "(pivot-idx [\:a] get count)" "(pivot-idx [] get count)" "(pivot-idx [\:a \:b \:c\\n            ] get count)" "(defn pivot-idx [l get count] (let [i (quot (count l) 2)] i))" "(pivot-idx [\:a \:b \:c\\n            ] get count)" "(pivot-idx [\:a \:b \:c \:d] get count)" "(pivot-idx [\:a \:b \:c \:d \:e] get count)" "(pivot-idx [\:a \:b \:c \:d \:e \:f] get count)" "(defn pivot-idx [l get count] (let [i (quot (count l) 2)] i))" "(defn pivot-idx [l get count] (quot (count l) 2))" "(defn qsort [l pivot-idx get count conj] \\n  (let [p (pivot-idx l get count)\\n        ll (qsort (take pivot-idx l) pivot-idx get count conj)\\n        lr (qsort (drop pivot-idx l) pivot-idx get count conj)]\\n    (concat ll [p] lr)))" "(defn pivot-idx [l] (quot (count l) 2))" "(defn qsort [l] \\n  (let [p (pivot-idx l)\\n        ll (qsort (take pivot-idx l))\\n        lr (qsort (drop pivot-idx l))]\\n    (concat ll [p] lr)))" "(doc take)" "(doc drop)" "(concat (take 3 [\:a \:b \:c \:d \:e]) (get [\:a \:b \:c \:d \:e] 3) (drop 3 [\:a \:b \:c \:d \:e]))" "(concat (take 3 [\:a \:b \:c \:d \:e]) (get 3 [\:a \:b \:c \:d \:e]) (drop 3 [\:a \:b \:c \:d \:e]))" "(doc get)" "(concat (take 3 [\:a \:b \:c \:d \:e]) (nth [\:a \:b \:c \:d \:e] 3) (drop 3 [\:a \:b \:c \:d \:e]))" "(doc nth)" "(concat (take 3 [\:a \:b \:c \:d \:e]) (nth [\:a \:b \:c \:d \:e] 3) (drop 3 [\:a \:b \:c \:d \:e]))" "(doc take)" "(doc drop)" "(concat (take 3 [\:a \:b \:c \:d \:e]) [(nth [\:a \:b \:c \:d \:e] 3)] (drop 3 [\:a \:b \:c \:d \:e]))" "(defn qsort [l] \\n  (let [p (pivot-idx l)\\n        ll (qsort (take pivot-idx l))\\n        lr (qsort (drop (inc pivot-idx) l))]\\n    (concat ll [p] lr)))" "(qsort [\:a \:d \:c \:b \:e])" "(defn pivot-idx [l] (quot (count l) 2))" "(defn qsort [l] \\n  (let [p (pivot-idx l)\\n        ll (qsort (take pivot-idx l))\\n        lr (qsort (drop (inc pivot-idx) l))]\\n    (concat ll [p] lr)))" "(defn qsort [l] \\n  (let [p (pivot-idx l)\\n        ll (qsort (take p l))\\n        lr (qsort (drop (inc p) l))]\\n    (concat ll [p] lr)))" "(defn pivot-idx [l] (quot (count l) 2))" "(defn qsort [l] \\n  (let [p (pivot-idx l)\\n        ll (qsort (take p l))\\n        lr (qsort (drop (inc p) l))]\\n    (concat ll [p] lr)))" "(qsort [\:a \:d \:c \:b \:e])" "(defn qsort [l] \\n  (when-let [p (pivot-idx l)]\\n    (let [ll (qsort (take p l))\\n          lr (qsort (drop (inc p) l))]\\n      (concat ll [p] lr))))" "(qsort [\:a \:d \:c \:b \:e])" "(defn qsort [l] \\n  (when-let [p (pivot-idx l)]\\n    (let [ll (qsort (take (dec p) l))\\n          lr (qsort (drop p l))]\\n      (concat ll [p] lr))))" "(qsort [\:a \:d \:c \:b \:e])" "(pivot-idx [\:a \:b \:c \:d \:e])" "(defn qsort [l] \\n  (when-let [p (pivot-idx l)]\\n    (let [ll (qsort (take p l))\\n          lr (qsort (drop (inc p) l))]\\n      (concat ll [p] lr))))" "(pivot-idx [\:a \:b \:c \:d \:e])" "(qsort [\:a \:d \:c \:b \:e])" "(defn qsort [l] \\n  (when-let [p (pivot-idx l)]\\n    (let [ll (qsort (take (dec p) l))\\n          lr (qsort (drop (inc p) l))]\\n      (concat ll [p] lr))))" "(qsort [\:a \:d \:c \:b \:e])" "(qsort nil)" "(pivot-idx nil)" "(pivot-idx [])" "(defn pivot-idx [l] (when l (quot (count l) 2)))" "(qsort nil)" "(qsort [\:a \:d \:c \:b \:e])" "(defn qsort [l] \\n  (when-let [p (pivot-idx l)]\\n    (let [ll (qsort (take (dec p) l))\\n          lr (qsort (drop p l))]\\n      (concat ll [p] lr))))" "(qsort [\:a \:d \:c \:b \:e])" "(qsort nil)" "(qsort [\:a])" "(defn qsort [l] \\n  (when-let [p (pivot-idx l)]\\n    (let [ll (qsort (take (dec p) l))\\n          lr (qsort (drop (inc p) l))]\\n      (concat ll [p] lr))))" "(qsort nil)" "(qsort [\:a])" "(qsort [\:a \:b])" "(defn qsort [l] \\n  (when-let [p (pivot-idx l)]\\n    (let [ll (qsort (take (dec p) l))\\n          lr (qsort (drop (inc p) l))]\\n      (concat ll [p] lr))))" "(pivot-idx [\:a])" "(take -1 [\:a])" "(qsort ())" "(defn pivot-idx [l] (when (seq l) (quot (count l) 2)))" "(qsort ())" "(qsort [\:a \:b])" "(qsort [\:a])" "(qsort [\:a \:d \:c \:b \:e])" "(defn qsort [l] \\n  (when-let [p (pivot-idx l)]\\n    (let [ll (qsort (take (dec p) l))\\n          lr (qsort (drop (inc p) l))]\\n      (concat ll [(nth l p)] lr))))" "(qsort [\:a \:d \:c \:b \:e])" "(defn qsort [l] \\n  (when-let [p (pivot-idx l)]\\n    (let [ll (qsort (take (dec p) l))\\n          lr (qsort (drop p l))]\\n      (concat ll [(nth l p)] lr))))" "(qsort [\:a \:d \:c \:b \:e])" "(defn qsort [l] \\n  (if (<\= (count l) 1)\\n    l\\n    (let [p (pivot-idx l)\\n          ll (qsort (take (dec p) l))\\n          lr (qsort (drop p l))]\\n      (concat ll [(nth l p)] lr))))" "(qsort [\:a \:d \:c \:b \:e])" "(defn qsort [l] \\n  (if (<\= (count l) 1)\\n    l\\n    (let [p (pivot-idx l)\\n          ll (qsort (take (dec p) l))\\n          lr (qsort p)]\\n      (concat ll [(nth l p)] lr))))" "(qsort [\:a \:d \:c \:b \:e])" "(defn qsort [l] \\n  (if (<\= (count l) 1)\\n    l\\n    (let [p (pivot-idx l)\\n          ll (qsort (take (dec p) l))\\n          lr (qsort (drop p l))]\\n      (concat ll [(nth l p)] lr))))" "(qsort [\:a \:d \:c \:b \:e])" "(defn qsort [l] \\n  (if (<\= (count l) 1)\\n    l\\n    (let [p (pivot-idx l)\\n          ll (qsort (take p l))\\n          lr (qsort (drop p l))]\\n      (concat ll [(nth l p)] lr))))" "(qsort [\:a \:d \:c \:b \:e])" "(defn qsort [l] \\n  (if (<\= (count l) 1)\\n    l\\n    (let [p (pivot-idx l)\\n          ll (qsort (take p l))\\n          lr (qsort (drop p l))]\\n      (concat ll [(nth l p)] lr))))" ";; Switching to ccw.util.handler-factory namespace" "(factory nil nil)" ";; Switching to ccw.util.handler-factory namespace" "(factory nil nil)" "(factory nil {\\"handler\\" \:foo})" "(doc require\\n     )" "(-> \\"foo/bar\\" (.split \\"/\\"))" "(let [[n f]] (-> \\"foo/bar\\" (.split \\"/\\")) [n f])" "(let [[n f] (-> \\"foo/bar\\" (.split \\"/\\"))] [n f])" "(doc proxy)" "(symbol \\"foo\\")" "(require (symbol \\"foo\\"))" "(require (symbol \\"ccw.util.handler-factory\\"))" "(find-var (symbol \\"ccw.util.handler-factory/factory\\"))" "(name (symbol \\"ccw.util.handler-factory/factory\\"))" "(namespace (symbol \\"ccw.util.handler-factory/factory\\"))" "(def handler \\"ccw.util.handler-factory/factory\\")" "((juxt (comp namespace symbol) symbol) handler)" "(namespace \\"ccw.util.handler-factory/factory\\")" "(namespace (symbol \\"ccw.util.handler-factory/factory\\"))" "(defn a [] \\"a\\")" "(defn doa [] (let [av (find-var \\"ccw.util.handler-factory/a\\")] (av)))" "(doa)" "(defn doa [] (let [av (find-var (symbol \\"ccw.util.handler-factory/a\\"))] (av)))" "(doa)" "(doa)\\n\\n" "(defn a [] \\"b\\")" "(doa)\\n\\n" "(doc proxy)" "(source proxy-super)" "(name lolo)" "(name \:lolo)" "(name \\"sdf/sdf\\")" "(name (symbol \\"sdf/f\\"))" "(name (quote sdf))" "(name (quote sdf/oij))" "(name (quote sdf/oij/sdf))" "(munge \\"toto\\")" "(munge (quote toto))" "(munge (quote toto_sdf))" "(munge \\"toto.titi_oo\\")" "(munge \\"toto.titi-oo\\")" "(namespace-munge \\"foo.bar.bi-sdf.boo-fi\\")" "(require 'clojure.string)" "(require '[clojure.string \:as str])" "(require '[clojure.contrib.str2 \:as str2])" "(require '[clojure.contrib.str-utils2 \:as str2])" "(str2/partition \#\\"b\\" \\"abba\\")" "(str2/partition \\"abba\\" \#\\"b\\" )" "(str/split \\"abba\\" \#\\"b\\")" "(str2/partition \\"abba\\" \#\\"b+\\" )" "(str/split \\"abba\\" \#\\"b+\\")" "(require 'ccw.util.string)" "(require 'ccw.editors.clojure.stacktrace-hyperlink)"]
eclipse.preferences.version=1
